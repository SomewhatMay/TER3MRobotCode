#pragma config(Sensor, in1,    leftLineFollower, sensorLineFollower)
#pragma config(Sensor, in2,    centerLineFollower, sensorLineFollower)
#pragma config(Sensor, in3,    rightLineFollower, sensorLineFollower)
#pragma config(Sensor, in6,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  touchSensor,    sensorTouch)
#pragma config(Sensor, dgtl8,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl11, armEncoder,     sensorQuadEncoder)
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393, openLoop)
#pragma config(Motor,  port6,           clawMotor,     tmotorVex393, openLoop)
#pragma config(Motor,  port7,           armMotor,      tmotorVex393, openLoop)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


/* Symbolic Constants */
#define DRIVE_TRAIN_SPEED 50
#define DRIVE_TRAIN_MULTIPLIER 0.95 // Linearly adjusts drivetrain delay
#define MOTOR_COMPENSATION 1.205 // Applied to left motor asymmetry
#define DRIVE_TRAIN_ANGLE 90 // Faces north - ASK MR MARIO
#define TURN_RATIO 680

#define ARM_SPEED 50
#define CLAW_SPEED 40

#define SQUARE_SIZE 25 // in centimeters
#define ROBOT_POSITION_X 1
#define ROBOT_POSITION_Y 2

/* Robot Properties */
static int driveTrainSpeed = 0; // range: [-127, 127]
static int driveTrainAngle = 0; // range: [0, 360)
static int robotPositionX = 0;
static int robotPositionY = 0;

static int armSpeed = 0;
static int armPosition = 0;

static int clawSpeed = 20;
static int clawPosition = 0;


/*
	Return the sign of x as a unit integer or zero.
*/
int sign(int x) {
	if (x > 0) return 1;
	if (x < 0) return -1;
	return 0;
}

/* DriveTrain Functions */
void setDriveTrainSpeed(int speed) {
	driveTrainSpeed = speed;
}

void setDriveTrainAngle(int angle) {
	driveTrainAngle = angle;
}

void stopDriveTrain() {
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}

/*
	Starts the drivetrain with MOTOR_COMPENSATION
	applied to the left motor.
*/
void startDrivetrain() {
	motor[leftMotor] = driveTrainSpeed * MOTOR_COMPENSATION;
	motor[rightMotor] = driveTrainSpeed;
}


/* 
	Calculate how many miliseconds the robot 
	will take to travel distance centimeters at
	driveTrainSpeed speed.
*/
float calculateTravelTime(float distance) {
	float distanceIn1Sec = 91.1753 * (log(driveTrainSpeed + 5.15744) / log(10)) - 122.446;
	return (distance / distanceIn1Sec) * 1000 * DRIVE_TRAIN_MULTIPLIER;
}

/* 
	Enable the drivetrain at driveTrainSpeed
	speed and yield the code until it reaches
	distance centimeters.
*/
void moveForward(int distance) {
	float time = calculateTravelTime(abs(distance));

	setDriveTrainSpeed(sign(distance) * abs(driveTrainSpeed));

	startDrivetrain();
	wait1Msec(time);
	stopDriveTrain();
}


void setRobotPosition(int x, int y) {
	robotPositionX = x;
	robotPositionY = y;
}

void moveToPosition(int x, int y) {
	int xDifference = x - robotPositionX;
	int yDifference = y - robotPositionY;
	int xDirection = sign(xDifference);
	int moveXFirst = 0;

	if (xDirection == 1 && driveTrainAngle == 90 || xDirection == -1 && driveTrainAngle == 270) {
		// we are already facing the right x direction
		moveXFirst = 1;
	}

	if (moveXFirst) {
		turnToPosition(xDirection * 90);
		wait1Msec(350);
		moveForward(abs(xDifference) * SQUARE_SIZE);
		wait1Msec(350);
	}

	turnToPosition(yDifference * 90);
	wait1Msec(350);
	moveForward(abs(yDifference) * SQUARE_SIZE);

	if (!moveXFirst) {
		wait1Msec(350);
		turnToPosition(xDirection * 90);
		wait1Msec(350);
		moveForward(abs(xDifference) * SQUARE_SIZE);
	}

	setRobotPosition(x, y);
}

/*
	Relative to the current heading,
	turn the robot degrees degrees with
	motors running at driveTrainSpeed speed.

	This function yields.
*/
void turn(int degrees) {
	short direction = sign(degrees);
	motor[rightMotor] = direction * -driveTrainSpeed;
	motor[leftMotor] = direction * driveTrainSpeed;

	wait1Msec(abs(degrees) * driveTrainSpeed / TURN_RATIO);
	stopDriveTrain();

	int newAngle = (driveTrainAngle + degrees) % 360;
	if (newAngle < 0) newAngle += 360;

	setDriveTrainAngle(newAngle);
}

/*
	Reorient the robot to face degrees in
	standard position with the range [0, 360).

	This function yields.
*/
void turnToPosition(int degrees) {
	degrees = degrees % 360;
	if (degrees < 0) degrees += 360;
	
	int difference = degrees - driveTrainAngle;
	turn(difference);
}
 

/* Arm Functions */
void setArmSpeed(int speed) {
	armSpeed = speed;
}

void setArmPosition(int degrees) {
	armPosition = degrees;
}

void stopArm() {
	motor[armMotor] = 0;
}


/*
	Relative to the current position,
	move the arm distance units up or down.

	This function yields.
*/
void moveArm(int distance){
	// Negative armSpeed ensures motor moves up.
	motor[armMotor] = -armSpeed * sign(distance);
	wait1Msec(abs(distance));
	stopArm();
}


/* Claw Functions */
void setClawSpeed(int speed) {
	clawSpeed = speed;
}

void setClawPosition(int degrees) {
	clawPosition = degrees;
}

void stopClaw() {
	motor[clawMotor] = 0;
}

/*
	Relative to the current position,
	open/close the claw distance units.

	This function yields.
*/
void moveClaw(int distance) {
	motor[clawMotor] = clawSpeed * sign(distance);
	wait1Msec(abs(distance));
	stopClaw();
}

void openClaw() {
	moveClaw(1000);
}

void closeClaw() {
	moveClaw(-1000);
}


/* Robot Reset */
void resetSystem() {
	stopDriveTrain();
	setDriveTrainAngle(0);
	setDriveTrainSpeed(0);

	stopArm();
	setArmSpeed(0);

	stopClaw();
	setClawSpeed(0);
}

/* Robot Initializer */
void initializeSystem() {
	setRobotPosition(ROBOT_POSITION_X, ROBOT_POSITION_Y);
	setDriveTrainSpeed(DRIVE_TRAIN_SPEED);
	setDriveTrainAngle(DRIVE_TRAIN_ANGLE); // robot points north
	stopDriveTrain();

	setArmSpeed(ARM_SPEED);
	setArmPosition(0);
	stopArm();

	setClawSpeed(CLAW_SPEED);
	setClawPosition(0);
	stopClaw();
}
