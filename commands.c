#pragma config(Sensor, in1,    leftLineFollower, sensorLineFollower)
#pragma config(Sensor, in2,    centerLineFollower, sensorLineFollower)
#pragma config(Sensor, in3,    rightLineFollower, sensorLineFollower)
#pragma config(Sensor, in6,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  touchSensor,    sensorTouch)
#pragma config(Sensor, dgtl8,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl11, armEncoder,     sensorQuadEncoder)
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393, openLoop)
#pragma config(Motor,  port6,           clawMotor,     tmotorVex393, openLoop)
#pragma config(Motor,  port7,           armMotor,      tmotorVex393, openLoop)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


#define DRIVE_TRAIN_SPEED 50
#define DRIVE_TRAIN_FACTOR 0.89
#define SPEED_PER_SECOND 39 // At speed 50
#define DRIVE_TRAIN_ANGLE 90
#define ARM_SPEED 20
#define CLAW_SPEED 40
#define COMPENSATION 1.18
#define TURN_SPEED 50
#define TURN_CONSTANT 720 / TURN_SPEED


static int driveTrainSpeed = 0;
static int driveTrainAngle = 0;
static int armSpeed = 0;
static int armPosition = 0;
static int clawSpeed = 0;
static int clawPosition = 0;


int sign(int x) {
	if (x > 0) return 1;
	if (x < 0) return -1;
	return 0;
}

/* DriveTrain -0Functions */
void setDriveTrainSpeed(int speed) {
	driveTrainSpeed = speed;
}

void setDriveTrainAngle(int angle) {
	driveTrainAngle = angle;
}

void stopDriveTrain() {
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}

void startDrivetrain(){
	motor[leftMotor] = driveTrainSpeed * COMPENSATION;
	motor[rightMotor] = driveTrainSpeed;

}

// dist is in cm
// return is in milliseconds
float calculateTravelTime(float dist) {
	float distIn1Sec = 91.1753 * (log(driveTrainSpeed + 5.15744) / log(10)) - 122.446;
	return (dist / distIn1Sec) * 1000 * DRIVE_TRAIN_FACTOR;
}

// moves the robot
void moveForward(int distance){
		float time = calculateTravelTime(distance);

		setDriveTrainSpeed(sign(distance) * abs(driveTrainSpeed));

		startDrivetrain();
		wait1Msec(time);
		stopDriveTrain();
}


// turn
void turn(int degrees){
	// Negative sign ensures that we are moving
	// counter-clockwise
	short direction = -sign(degrees);
	motor[rightMotor] = direction * -TURN_SPEED;
	motor[leftMotor] = direction * TURN_SPEED;

	wait1Msec(abs(degrees) * TURN_CONSTANT);
	stopDriveTrain();
}



/* Arm Functions */
void setArmSpeed(int speed) {
	armSpeed = speed;
}

void setArmPosition(int degrees) {
		armPosition = degrees;
}

void stopArm() {
	motor[armMotor] = 0;
}


/* Claw Functions */
void setClawSpeed(int speed) {
	clawSpeed = speed;
}

void setClawPosition(int degrees) {
	clawPosition = degrees;
}

void stopClaw() {
	motor[clawMotor] = 0;
}


/* Robot Reset */
void resetSystem() {
	stopDriveTrain();
	setDriveTrainAngle(0);
	setDriveTrainSpeed(0);

	stopArm();
	setArmSpeed(0);

	stopClaw();
	setClawSpeed(0);
}

/* Robot Initializer */
void initializeSystem() {
	setDriveTrainSpeed(DRIVE_TRAIN_SPEED);
	setDriveTrainAngle(DRIVE_TRAIN_ANGLE); // robot points north
	stopDriveTrain();
	setArmSpeed(ARM_SPEED);
	setArmPosition(0);
	stopArm();
	setClawSpeed(CLAW_SPEED);
	setClawPosition(0);
	stopClaw();
}
