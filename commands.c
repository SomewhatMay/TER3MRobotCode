#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    leftLineFollower, sensorLineFollower)
#pragma config(Sensor, in2,    centerLineFollower, sensorLineFollower)
#pragma config(Sensor, in3,    rightLineFollower, sensorLineFollower)
#pragma config(Sensor, in6,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  touchSensor,    sensorTouch)
#pragma config(Sensor, dgtl8,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl11, armEncoder,     sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  rightIME,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  leftIME,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  armIME,         sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393_HBridge, openLoop, driveLeft, encoderPort, I2C_2)
#pragma config(Motor,  port6,           clawMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armMotor,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393_HBridge, openLoop, driveRight, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* Symbolic Constants */
#define DRIVE_TRAIN_SPEED 50
#define DRIVE_TRAIN_MULTIPLIER 0.83 // Linearly adjusts drivetrain delay
#define MOTOR_COMPENSATION 1.095 // Applied to left motor asymmetry
#define DRIVE_TRAIN_ANGLE 0 // Faces north - ASK MR MARIO
#define TURN_RATIO 600

#define ARM_SPEED 50
#define CLAW_SPEED 40

#define SQUARE_SIZE 37 // in centimeters
#define ROBOT_POSITION_R 2
#define ROBOT_POSITION_C 1

/* Robot Properties */
static int driveTrainSpeed = 0; // range: [-127, 127]
static int driveTrainAngle = 0; // range: [0, 360)
static int robotPositionR = 0;
static int robotPositionC = 0;

static int armSpeed = 0;
static int armPosition = 0;

static int clawSpeed = 20;
static int clawPosition = 0;

void moveArm(int distance);
void closeClaw();
void openClaw();


/*
	Return the sign of x as a unit integer or zero.
*/
int sign(int x) {
	if (x > 0) return 1;
	if (x < 0) return -1;
	return 0;
}

/* DriveTrain Functions */
void setDriveTrainSpeed(int speed) {
	driveTrainSpeed = speed;
}

void setDriveTrainAngle(int angle) {
	driveTrainAngle = angle;
}

void stopDriveTrain() {
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}

/*
	Starts the drivetrain with MOTOR_COMPENSATION
	applied to the left motor.
*/
void startDrivetrain() {
	motor[leftMotor] = driveTrainSpeed * MOTOR_COMPENSATION;
	motor[rightMotor] = driveTrainSpeed;
}


/*
	Calculate how many miliseconds the robot
	will take to travel distance centimeters at
	driveTrainSpeed speed.
*/
float calculateTravelTime(float distance) {
	float distanceIn1Sec = 91.1753 * (log(driveTrainSpeed + 5.15744) / log(10)) - 122.446;
	return (distance / distanceIn1Sec) * 1000 * DRIVE_TRAIN_MULTIPLIER;
}

/*
	Enable the drivetrain at driveTrainSpeed
	speed and yield the code until it reaches
	distance centimeters.
*/
void moveForward(int distance) {
	float time = calculateTravelTime(abs(distance));

	setDriveTrainSpeed(sign(distance) * abs(driveTrainSpeed));

	startDrivetrain();
	wait1Msec(time);
	stopDriveTrain();
}


void setRobotPosition(int r, int c) {
	robotPositionR = r;
	robotPositionC = c;
}

/*
	Relative to the current heading,
	turn the robot degrees degrees with
	motors running at driveTrainSpeed speed.

	This function yields.
*/
void turn(int degrees) {
	short direction = sign(degrees);
	motor[rightMotor] = direction * -driveTrainSpeed;
	motor[leftMotor] = direction * driveTrainSpeed * MOTOR_COMPENSATION;

	wait1Msec(abs(degrees) * TURN_RATIO / driveTrainSpeed);
	stopDriveTrain();

	int newAngle = (driveTrainAngle + degrees) % 360;
	if (newAngle < 0) newAngle += 360;

	setDriveTrainAngle(newAngle);
}

/*
	Reorient the robot to face degrees in
	standard position with the range [0, 360).

	This function yields.
*/
void turnToPosition(int degrees) {
	int difference = degrees - driveTrainAngle;
	if (abs(difference) > 180) {
		difference = (360 - abs(difference)) * -sign(difference);
	}
	turn(difference);
}

/*
	Move the robot to position row, column in the smallest
	amount of time.

	This function yields.
*/
void moveToPosition(int row, int col) {
	// Subtracting row from current row position
	// will yield a positive rowDifference, which is ideal
	// since y decreases as we move up.
	int rowDifference = robotPositionR - row;
	int colDifference = col - robotPositionC;
	
	int horizontalDirection = sign(colDifference);
	int verticalDirection = sign(rowDifference);

	if (horizontalDirection != 0) {
		turnToPosition(horizontalDirection * 90);
		wait1Msec(350);
		moveForward(abs(colDifference) * SQUARE_SIZE);
		wait1Msec(350);
	}

	if (verticalDirection != 0) {
		turnToPosition(abs(verticalDirection - 1) * 90);
		wait1Msec(350);
		moveForward(abs(rowDifference) * SQUARE_SIZE);
		wait1Msec(350);
	}

	setRobotPosition(row, col);
}

void interact(int pickup){
	moveForward(10);
	wait1Msec(350);
	if (pickup){
		closeClaw();
		wait1Msec(350);
		moveArm(400);
		wait1Msec(350);
	}
	else {
		moveArm(-400);
		wait1Msec(350);
		openClaw();
		wait1Msec(350);
	}
	moveForward(-10);
	wait1Msec(350);
}


/* Arm Functions */
void setArmSpeed(int speed) {
	armSpeed = speed;
}

void setArmPosition(int degrees) {
	armPosition = degrees;
}

void stopArm() {
	motor[armMotor] = 0;
}


/*
	Relative to the current position,
	move the arm distance units up or down.

	This function yields.
*/
void moveArm(int distance){
	// Negative armSpeed ensures motor moves up.
	motor[armMotor] = armSpeed * sign(distance);
	wait1Msec(abs(distance));
	stopArm();
}


/* Claw Functions */
void setClawSpeed(int speed) {
	clawSpeed = speed;
}

void setClawPosition(int degrees) {
	clawPosition = degrees;
}

void stopClaw() {
	motor[clawMotor] = 0;
}

/*
	Relative to the current position,
	open/close the claw distance units.

	This function yields.
*/
void moveClaw(int distance) {
	motor[clawMotor] = clawSpeed * sign(distance);
	wait1Msec(abs(distance));
	stopClaw();
}

void openClaw() {
	moveClaw(1000);
}

void closeClaw() {
	moveClaw(-1000);
}


/* Robot Reset */
void resetSystem() {
	stopDriveTrain();
	setDriveTrainAngle(0);
	setDriveTrainSpeed(0);

	stopArm();
	setArmSpeed(0);

	stopClaw();
	setClawSpeed(0);
}

/* Robot Initializer */
void initializeSystem() {
	setRobotPosition(ROBOT_POSITION_R, ROBOT_POSITION_C);
	setDriveTrainSpeed(DRIVE_TRAIN_SPEED);
	setDriveTrainAngle(DRIVE_TRAIN_ANGLE); // robot points north
	stopDriveTrain();

	setArmSpeed(ARM_SPEED);
	setArmPosition(0);
	stopArm();

	setClawSpeed(CLAW_SPEED);
	setClawPosition(0);
	stopClaw();
}
